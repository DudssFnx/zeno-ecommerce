Este projeto j√° est√° avan√ßado e possui toda a modelagem de banco pronta usando Drizzle ORM.
Os schemas j√° existem em shared/schema/* (companies, users, orders, products, etc.).
O banco PostgreSQL j√° est√° provisionado no Railway e a vari√°vel DATABASE_URL j√° est√° configurada no Replit.
O backend j√° conecta ao banco com Drizzle.

Objetivo agora:
Ativar e consolidar o banco de dados para que o MVP funcione de ponta a ponta, garantindo persist√™ncia real (PostgreSQL) e removendo depend√™ncias de storage tempor√°rio/mem√≥ria.

IMPORTANTE:

N√ÉO recriar schemas

N√ÉO refatorar arquitetura

N√ÉO alterar frontend

N√ÉO remover funcionalidades existentes

Fazer o menor ajuste poss√≠vel, respeitando o c√≥digo atual

O foco √© MVP funcional, n√£o sistema final

üéØ ETAPA 1 ‚Äî CONSOLIDAR SCHEMA DRIZZLE
1.1 Conferir arquivo indexador de schema

Garantir que o arquivo:

shared/schema.ts


exporta TODOS os schemas existentes em shared/schema/.

Exemplo esperado:

export * from "./schema/companies.schema";
export * from "./schema/users.schema";
export * from "./schema/orders.schema";
export * from "./schema/orderItems.schema";
export * from "./schema/products.schema";
export * from "./schema/payments.schema";
export * from "./schema/userCompanies.schema";


üëâ Se algum schema existir na pasta e n√£o estiver exportado, apenas adicionar o export.

1.2 Conferir configura√ß√£o do Drizzle

Garantir que drizzle.config.ts esteja apontando para:

schema: "./shared/schema.ts"


E usando:

connectionString: process.env.DATABASE_URL


Sem alterar paths desnecessariamente.

1.3 Ativar o banco

Executar o comando de sincroniza√ß√£o do Drizzle:

npm run db:push


Esse comando deve:

Criar todas as tabelas no PostgreSQL

Manter rela√ß√µes

N√£o apagar dados

N√£o gerar SQL manual

üéØ ETAPA 2 ‚Äî CONSOLIDAR SERVICES PARA USAR BANCO REAL
Objetivo

Garantir que os services principais do MVP utilizem Drizzle + PostgreSQL, e n√£o storage tempor√°rio.

Ordem correta (n√£o mudar):

companies.service.ts

users.service.ts

orders.service.ts

2.1 Companies (obrigat√≥rio para MVP)

Arquivo:

server/services/companies.service.ts


Ajustar para:

Usar db.insert(companies)

Usar db.select().from(companies)

Remover depend√™ncia de storage se existir

Manter tipagem e retorno atuais

üëâ Esse service √© a base do atacado.

2.2 Users (login funcional)

Arquivo:

server/services/users.service.ts


Ajustar para:

Criar usu√°rio no banco

Relacionar com company_id

Manter hash de senha existente

N√ÉO mudar fluxo de autentica√ß√£o

2.3 Orders (pedido m√≠nimo do MVP)

Arquivo:

server/services/orders.service.ts


Ajustar para:

Criar pedido simples

Persistir company_id, total, status

N√£o mexer ainda em estoque avan√ßado ou fiscal

üéØ ETAPA 3 ‚Äî MVP FUNCIONAL (CRIT√âRIOS DE SUCESSO)

O MVP ser√° considerado PRONTO quando:

‚úÖ Cadastro de empresa (atacado) persiste no banco

‚úÖ Usu√°rio consegue se cadastrar e logar

‚úÖ Pedido √© criado e salvo no PostgreSQL

‚úÖ Recarregar o app n√£o perde dados

‚úÖ Nenhum dado cr√≠tico depende de mem√≥ria/local storage

üö® REGRAS IMPORTANTES

N√ÉO refatorar frontend

N√ÉO criar novas tabelas

N√ÉO criar migrations complexas

N√ÉO apagar c√≥digo antigo sem necessidade

Se algo estiver sendo usado em produ√ß√£o, preservar

üìå OBJETIVO FINAL

Deixar o projeto:

Est√°vel

Persistente

Pronto para valida√ß√£o real com cliente

Base s√≥lida para evoluir depois para ERP / B2B completo

Resumo:
Ative o banco existente, conecte os services essenciais e entregue um MVP funcional, sem reescrever o projeto.